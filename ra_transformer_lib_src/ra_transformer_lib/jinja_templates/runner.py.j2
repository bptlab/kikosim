#!/usr/bin/env python3
"""
Complete Round-Based Self-Messaging Virtual Time System Runner

Runs the complete round-based self-messaging time coordination system with:
- TimeService using new round-based self-messaging protocol
- Business agents creating and processing orders
- Resource agents using self-messaging pattern for time coordination
- All agents participating in round-based time coordination

Protocol Flow:
1. TimeService sends TimeUpdate[roundId, now] to all agents
2. Agents execute due tasks and send themselves Reminder[roundId] 
3. Agents react to Reminder and send Hold[roundId, agentName, nextTime] or Passivate[roundId, agentName]
4. TimeService advances time and starts next round

This demonstrates the beautiful self-messaging pattern that works WITH BSPL's FIFO ordering.
"""

import subprocess
import signal
import time
import os
import sys
from pathlib import Path
import redis

def cleanup_processes():
    """Kill any existing agent processes - disabled for concurrent simulation support."""
    print("üßπ Cleanup disabled to support concurrent simulations")
    # Note: Process cleanup is now handled by the simulation runner
    # to avoid killing processes from other concurrent simulations

def check_redis():
    """Check if Redis is available (started by web app)."""
    print("üî¥ Checking Redis connection...")
    try:
        redis_client = redis.Redis(host='localhost', port=6379, db=0, decode_responses=True)
        redis_client.ping()
        print("‚úÖ Redis server is available")
        return True
    except Exception as e:
        print(f"‚ö†Ô∏è Redis connection error: {e}")
        print("   Redis should be started by the web application")
        return False

def cleanup_redis_logs(simulation_id: str, run_id: str):
    """Clean up Redis logs for this specific run."""
    try:
        redis_client = redis.Redis(host='localhost', port=6379, db=0, decode_responses=True)
        
        # Find and delete keys for this specific run
        pattern = f"logs:{simulation_id}:{run_id}:*"
        keys = redis_client.keys(pattern)
        if keys:
            redis_client.delete(*keys)
            print(f"üßπ Cleaned up {len(keys)} Redis log keys for run {run_id}")
    except Exception as e:
        print(f"‚ö†Ô∏è Redis cleanup warning: {e}")

def start_timeservice(max_rounds=200, simulation_id=None, run_id=None, simulation_start_time=None):
    """Start the new round-based TimeService agent."""
    print(f"üì° Starting TimeService (max_rounds={max_rounds})...")
    
    # Set up environment variables for logging context
    env = os.environ.copy()
    if simulation_id:
        env["KIKOSIM_SIMULATION_ID"] = simulation_id
    if run_id:
        env["KIKOSIM_RUN_ID"] = run_id
    if simulation_start_time:
        env["KIKOSIM_START_TIME"] = str(simulation_start_time)
    
    timeservice_proc = subprocess.Popen([
        sys.executable, "timeservice_agent.py", "--max-rounds", str(max_rounds)
    ], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, env=env, preexec_fn=os.setsid)
    time.sleep(3)  # Give TimeService time to start
    return timeservice_proc

def start_resource_agents(simulation_id=None, run_id=None, simulation_start_time=None):
    """Start all resource agents."""
    resource_procs = []
    
    # Set up environment variables for logging context
    env = os.environ.copy()
    if simulation_id:
        env["KIKOSIM_SIMULATION_ID"] = simulation_id
    if run_id:
        env["KIKOSIM_RUN_ID"] = run_id
    if simulation_start_time:
        env["KIKOSIM_START_TIME"] = str(simulation_start_time)
    
    # Start all resource agents for TimeService coordination
{{ ra_spawns }}
    
    return resource_procs

def _spawn_ra(label: str, ra_agent_name: str, env=None):
    """Helper function to spawn a resource agent."""
    THIS_DIR = Path(__file__).resolve().parent
    RA_SCRIPT = THIS_DIR / "resource_agent.py"
    
    print(f"ü§ñ Starting ResourceAgent: {label}")
    proc = subprocess.Popen([
        sys.executable, str(RA_SCRIPT), ra_agent_name
    ], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, env=env, preexec_fn=os.setsid)
    time.sleep(0.5)  # Brief delay between starting agents
    return proc

def start_business_agents(simulation_id=None, run_id=None, simulation_start_time=None):
    """Start all business agents."""
    business_procs = []
    
    # Start all business agents for TimeService coordination
{{ launch_spawns }}
    
    return business_procs

def _spawn_business(procs_list, label: str, filename: str, simulation_id=None, run_id=None, simulation_start_time=None):
    """Helper function to spawn a business agent."""
    THIS_DIR = Path(__file__).resolve().parent
    
    print(f"üè¢ Starting {label}")
    cmd = [sys.executable, str(THIS_DIR / filename)]
    if simulation_id:
        cmd.extend(['--simulation-id', simulation_id])
    if run_id:
        cmd.extend(['--run-id', run_id])
    if simulation_start_time:
        cmd.extend(['--start-time', str(simulation_start_time)])
    
    proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, preexec_fn=os.setsid)
    procs_list.append(proc)
    time.sleep(1)  # Brief delay between starting agents

def monitor_processes(all_processes, process_info=None):
    """Monitor all processes and log any deaths with detailed diagnostics."""
    dead_processes = []
    for i, proc in enumerate(all_processes):
        if proc.poll() is not None:
            dead_processes.append((i, proc.returncode, proc))
    
    if dead_processes:
        print(f"üíÄ {len(dead_processes)} process(es) have died:")
        for i, returncode, proc in dead_processes:
            # Try to identify which process this is
            process_name = "Unknown Process"
            if process_info and i < len(process_info):
                process_name = process_info[i]
            
            print(f"   üíÄ {process_name} (index {i}) exited with code {returncode}")
            
            # Try to capture any final output/errors
            try:
                if proc.stdout:
                    stdout_data = proc.stdout.read()
                    if stdout_data:
                        print(f"      üìù Final output: {stdout_data[-20000:]}")  # Last 200 chars
                if proc.stderr:
                    stderr_data = proc.stderr.read()
                    if stderr_data:
                        print(f"      ‚ùå Error output: {stderr_data[-20000:]}")  # Last 200 chars
            except Exception as e:
                print(f"      ‚ö†Ô∏è Could not read process output: {e}")
            
            # Provide exit code interpretation
            if returncode == 0:
                print(f"      ‚úÖ Clean exit (code 0) - process completed normally")
            elif returncode == -9:
                print(f"      üí• SIGKILL (code -9) - process was force-killed")
            elif returncode == -15:
                print(f"      üõë SIGTERM (code -15) - process was terminated")
            elif returncode == 1:
                print(f"      ‚ùå General error (code 1) - check logs for details")
            else:
                print(f"      üîç Unusual exit code {returncode} - investigate further")
        
        # Remove dead processes from monitoring list to avoid repeated logging
        alive_processes = [proc for proc in all_processes if proc.poll() is None]
        all_processes[:] = alive_processes
        
        # If more than half the processes are dead, consider simulation failed
        if len(all_processes) < 3:
            print("üí• Too many processes have died - simulation appears to have failed")
            return True
    
    return False

def main(simulation_id=None, run_id=None, max_rounds=200):
    """Run the complete round-based self-messaging virtual time system."""
    print("üöÄ Starting Complete Round-Based Self-Messaging Virtual Time System")
    print("=" * 80)
    print()
    print("This system demonstrates the new self-messaging time coordination:")
    print("1. üì° TimeService sends TimeUpdate[roundId, now] to all agents")
    print("2. üéØ Agents execute tasks and send themselves Reminder[roundId]")
    print("3. üì® Agents react to Reminder and send Hold/Passivate to TimeService")
    print("4. ‚è∞ TimeService advances time and starts next round")
    print()
    print("Watch for round-based coordination with realistic day-based timestamps!")
    if simulation_id and run_id:
        print(f"üìä Simulation: {simulation_id}, Run: {run_id}")
    print("=" * 80)
    
    # Clean up any existing processes
    cleanup_processes()
    
    # Check Redis server (should be started by web app)
    if not check_redis():
        print("üí• Redis not available. Exiting.")
        return
    
    all_processes = []
    
    try:
        # Capture simulation start time for consistent agent timing
        import time
        simulation_start_time = time.time()
        
        # Start business agents
        business_procs = start_business_agents(simulation_id, run_id, simulation_start_time)
        all_processes.extend(business_procs)
        
        # Start resource agents
        resource_procs = start_resource_agents(simulation_id, run_id, simulation_start_time)
        all_processes.extend(resource_procs)
        
        # Start TimeService after resource agents
        timeservice_proc = start_timeservice(max_rounds, simulation_id, run_id, simulation_start_time)
        all_processes.append(timeservice_proc)
        
        # Create process info for better diagnostics
        process_info = []
        business_agent_names = ["Market", "Retailer", "Supplier"]  # Known agent names
        process_info.extend([f"{name} (Business)" for name in business_agent_names[:len(business_procs)]])
        
        # For resource agents, we need to look at what was spawned
        resource_agent_count = len(resource_procs)
        for i in range(resource_agent_count):
            process_info.append(f"Resource Agent {i+1}")
        
        process_info.append("TimeService")
        
        print()
        print("‚úÖ All agents started successfully!")
        print(f"üìä Running {len(all_processes)} total processes:")
        print(f"   üì° 1 TimeService")
        print(f"   üè¢ {{ agent_names|length }} Business agents")
        print(f"   ü§ñ {{ ra_count }} Resource agents")
        print()
        print("üîç Logs are stored in Redis during simulation (fast performance)")
        print("üìÑ Log files will be exported to agent_logs/ after completion")
        print(f"‚è∞ Simulation will automatically stop after {max_rounds} rounds")
        print("üõë Press Ctrl+C to stop early")
        print("=" * 80)
        
        # Monitor and keep running until TimeService completes or timeout
        try:
            timeout_seconds = max_rounds * 10  # Allow 10 seconds per round as safety
            start_time = time.time()
            
            while True:
                # Monitor processes and check if too many died
                too_many_dead = monitor_processes(all_processes, process_info)
                if too_many_dead:
                    print("üí• Stopping simulation due to process failures")
                    break
                
                # Check if TimeService has completed
                if timeservice_proc.poll() is not None:
                    exit_code = timeservice_proc.returncode
                    if exit_code == 0:
                        print(f"‚úÖ TimeService completed successfully")
                    else:
                        print(f"‚ùå TimeService exited with code {exit_code}")
                    break
                
                # Check for timeout
                elapsed = time.time() - start_time
                if elapsed > timeout_seconds:
                    print(f"‚è∞ Simulation timed out after {elapsed:.1f}s (max: {timeout_seconds}s)")
                    break
                    
                time.sleep(2)
                
        except KeyboardInterrupt:
            print("\nüõë Received interrupt signal. Shutting down...")
            
    except Exception as e:
        print(f"üí• Error starting system: {e}")
        import traceback
        traceback.print_exc()
        
    finally:
        # Cleanup
        print("üßπ Cleaning up all processes...")
        
        # Send SIGTERM to all process groups (graceful shutdown)
        for proc in all_processes:
            try:
                if proc.poll() is None:
                    os.killpg(os.getpgid(proc.pid), signal.SIGTERM)
            except (ProcessLookupError, OSError):
                pass
        
        # Wait a bit for graceful shutdown
        time.sleep(3)
        
        # Force kill any remaining process groups
        for proc in all_processes:
            try:
                if proc.poll() is None:
                    os.killpg(os.getpgid(proc.pid), signal.SIGKILL)
                    proc.wait(timeout=5)
            except (ProcessLookupError, OSError, subprocess.TimeoutExpired):
                pass
        
        # Export Redis logs to files before cleanup
        print("üìÑ Exporting Redis logs to files...")
        try:
            from simple_logging import export_redis_logs_to_files
            export_redis_logs_to_files(simulation_id, run_id)
        except Exception as e:
            print(f"‚ö†Ô∏è Failed to export logs: {e}")
        
        # Clean up Redis logs for this run
        if simulation_id and run_id:
            cleanup_redis_logs(simulation_id, run_id)
        
        # Final cleanup
        cleanup_processes()
        
        print("üèÅ All processes stopped.")

def signal_handler(signum, frame):
    """Handle termination signals by triggering cleanup."""
    print(f"\nüì° Received signal {signum}, initiating graceful shutdown...")
    sys.exit(0)

if __name__ == "__main__":
    # Register signal handlers
    signal.signal(signal.SIGTERM, signal_handler)
    signal.signal(signal.SIGINT, signal_handler)
    
    # Parse command line arguments
    duration = {{ default_duration }}
    max_rounds = {{ max_rounds }}
    simulation_id = None
    run_id = None
    
    i = 1
    while i < len(sys.argv):
        if sys.argv[i] == "--seconds" and i + 1 < len(sys.argv):
            duration = int(sys.argv[i + 1])
            i += 2
        elif sys.argv[i] == "--max-rounds" and i + 1 < len(sys.argv):
            max_rounds = int(sys.argv[i + 1])
            i += 2
        elif sys.argv[i] == "--simulation-id" and i + 1 < len(sys.argv):
            simulation_id = sys.argv[i + 1]
            i += 2
        elif sys.argv[i] == "--run-id" and i + 1 < len(sys.argv):
            run_id = sys.argv[i + 1]
            i += 2
        elif sys.argv[i].isdigit():
            # Handle direct numeric argument format (for backwards compatibility)
            duration = int(sys.argv[i])
            i += 1
        else:
            i += 1
    
    try:
        main(simulation_id, run_id, max_rounds)
    except KeyboardInterrupt:
        # This will be caught by the signal handler
        pass