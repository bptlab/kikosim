# ra_helpers.py
"""
Resource Agent Helpers

This module provides the core utilities needed for resource injection.
An injector tool only needs to:
1. Import create_resource_manager from this module
2. Add the resource setup boilerplate 
3. Replace @adapter.reaction with @deferred_reaction

That's it! No complex configuration or markers needed.
"""
from typing import Dict, Callable, Awaitable, Optional
from simple_logging import setup_logger
from ResourceAgent import GiveTask
import itertools

__all__ = ["mk_deferred", "new_task_id", "create_resource_manager", "parse_duration", "sample_duration", "DURATION_PATTERNS"]

import os
log = setup_logger(
    "ra_helpers", 
    simulation_id=os.getenv("KIKOSIM_SIMULATION_ID"),
    run_id=os.getenv("KIKOSIM_RUN_ID")
)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  generic helpers
_counter = 0
def new_task_id(prefix: str) -> str:
    """Monotonic task-id generator (no clock collisions)."""
    global _counter
    _counter += 1
    return f"{prefix}_{_counter}"

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  factory
def mk_deferred(
    adapter_decorator,
    prefix: str,
    pending_tasks: Dict[str, Awaitable],
    send_give_task_factory: Callable[[str], Callable[[str], Awaitable[None]]],
    empty_return=None,
):
    """
    Returns a decorator that wraps any handler so it is executed
    only after the ResourceAgent signals completion.

    Each caller passes its *own* `pending_tasks` so state is NOT shared 
    across agents or modules.
    
    send_give_task_factory: Function that takes order_id and returns send_task function
    """
    
    def outer(func):
        async def core(msg, *a, **kw):            
            task_id = new_task_id(prefix)
            
            enactment_id = _extract_enactment_id(msg)
            

            async def execute_business_logic():
                """Execute business logic when ResourceAgent completes."""
                try:
                    await func(msg, *a, **kw)
                except Exception as e:
                    log.error(f"ðŸ’¥ {prefix}: business logic failed for {task_id}: {e}")
                    raise

            # Store the pending task
            pending_tasks[task_id] = execute_business_logic
            
            # Create order-specific task sender and send task to ResourceAgent
            send_task = send_give_task_factory(enactment_id)
            await send_task(task_id)
            
            return empty_return

        # Register with BSPL adapter
        adapter_decorator(core)   # â† register with BSPL (returns None)
        return core               # â† keep a *callable* reference for your code
    return outer


def _extract_enactment_id(msg) -> str:
    """Extract case ID from message for process mining."""
    # Handle both attribute and dictionary access
    try:
        # First, try BSPL message dictionary access (most common case)
        if hasattr(msg, '__getitem__'):
            try:
                value = msg['id']
                if value is not None:
                    return str(value)
            except (KeyError, TypeError):
                pass
                
    except Exception as e:
        log.debug(f"Error extracting enactment ID: {e}")

    return "unknown"

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  shared resource utilities
# Added *principal* parameter to support capability-based pools (Idea 2).
def create_resource_manager(
    adapter,
    pending_tasks: dict,
    *,
    principal: Optional[str] = None,
):
    """
    Create resource management functions for deferred agents.

    Parameters
    ----------
    adapter : Adapter
        BSPL adapter of the *business* agent.
    pending_tasks : dict[str, Awaitable]
        Local storage that maps *taskID* â†’ coroutine so the CompleteTask handler
        can resume the business logic.
    principal : str, optional
        Principal name for agent pool selection

    Returns
    -------
    (create_task_sender_factory, deferred_reaction)
        Same as before, now with transparent round-robin support.
    """

    # ------------------------------------------------------------------
    # task_config.py is generated by *ra_transformer.py* and now contains
    from task_config import TASK_SETTINGS

    # Cache per-agent_type cycles (principal-specific to prevent cross-contamination)
    _agent_cycle_cache: Dict[str, itertools.cycle] = {}

    def create_task_sender_factory(prefix: str):
        """Create sender factory specialised for a reaction handler (*prefix*)."""

        if prefix not in TASK_SETTINGS:
            raise KeyError(f"Missing TASK_SETTINGS entry for handler '{prefix}'")

        task_setting = TASK_SETTINGS[prefix]
        
        # Support both old format (agent_type, duration) and new format (agent_type, mean, std_dev)
        if len(task_setting) == 2:
            agent_type, duration_value = task_setting
            if isinstance(duration_value, str):
                # New string format: "1.5dÂ±0.5d" 
                duration = duration_value
            else:
                # Old numeric format: convert to string
                duration = f"{duration_value}d"
        elif len(task_setting) == 3:
            agent_type, mean_days, std_days = task_setting
            if std_days == 0:
                duration = f"{mean_days}d"
            else:
                duration = f"{mean_days}dÂ±{std_days}d"
        else:
            raise ValueError(f"Invalid TASK_SETTINGS format for '{prefix}': {task_setting}")

        def task_sender_factory(id: str):
            """Return *send_task* bound to specific *id*."""

            async def send_task(task_id: str) -> None:
                """Send *GiveTask* to an appropriate RA chosen by strategy (round-robin or random)."""
                # Import agent_pools and agent_strategies from configuration for destination passing
                from configuration import agent_pools, agent_strategies, agents
                import random
                
                # Get agent pool for this principal and agent type
                if principal not in agent_pools:
                    raise RuntimeError(f"Principal '{principal}' not found in agent_pools")
                if agent_type not in agent_pools[principal]:
                    raise RuntimeError(f"Agent type '{agent_type}' not found for principal '{principal}' in agent_pools")
                
                # Get strategy for this agent type (default to round_robin if not found)
                strategy = agent_strategies.get((principal, agent_type), "round_robin")
                
                # Select agent based on strategy
                if strategy == "random":
                    # Use random selection
                    available_agents = agent_pools[principal][agent_type]
                    selected_agent = random.choice(available_agents)
                else:
                    # Use round-robin (default behavior)
                    cache_key = f"{principal}:{agent_type}"
                    if cache_key not in _agent_cycle_cache:
                        _agent_cycle_cache[cache_key] = itertools.cycle(agent_pools[principal][agent_type])
                    selected_agent = next(_agent_cycle_cache[cache_key])
                
                # Send with destination passing
                give_task_msg = GiveTask(
                    taskID=task_id,
                    duration=duration,
                    id=id,  # Use market order ID as primary case identifier
                    taskType=prefix,  # Pass the task type for process mining
                )
                # Get endpoint from agents config (handle list of endpoints)
                agent_endpoints = agents[selected_agent]
                if isinstance(agent_endpoints, list):
                    endpoint = agent_endpoints[0]  # Take first endpoint
                else:
                    endpoint = agent_endpoints
                # Set destination directly on the message object
                give_task_msg.dest = endpoint
                
                await adapter.send(give_task_msg)

            return send_task

        return task_sender_factory

    def deferred_reaction(decorator, prefix: str):
        """Create deferred reaction with automatic order ID extraction."""
        task_sender_factory = create_task_sender_factory(prefix)
        return mk_deferred(decorator, prefix, pending_tasks, task_sender_factory, None)
    
    return create_task_sender_factory, deferred_reaction


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  duration variance support
import re
import random
import math
from typing import Union

def parse_duration(duration_str: str) -> tuple[float, float]:
    """
    Parse duration string with optional normal distribution specification.
    
    Supported formats:
    - "1.5d" - Fixed 1.5 days (std_dev = 0)
    - "1.5dÂ±0.5d" - Normal distribution with mean=1.5d, std_dev=0.5d
    - "2hÂ±30m" - Normal distribution with mean=2h, std_dev=30m
    
    Returns:
        tuple[float, float]: (mean_duration_days, std_dev_days)
    """
    duration_str = duration_str.strip()
    
    # Check for normal distribution format: "1.5dÂ±0.5d"
    normal_match = re.match(r'^(\d+\.?\d*)\s*([dhms]?)\s*Â±\s*(\d+\.?\d*)\s*([dhms]?)$', duration_str)
    if normal_match:
        mean_value = float(normal_match.group(1))
        mean_unit = normal_match.group(2) or 'd'
        std_value = float(normal_match.group(3))
        std_unit = normal_match.group(4) or 'd'
        
        # Convert to days
        unit_multipliers = {'d': 1.0, 'h': 1/24, 'm': 1/(24*60), 's': 1/(24*60*60)}
        
        if mean_unit not in unit_multipliers:
            raise ValueError(f"Invalid time unit for mean: {mean_unit}")
        if std_unit not in unit_multipliers:
            raise ValueError(f"Invalid time unit for std dev: {std_unit}")
        
        mean_days = mean_value * unit_multipliers[mean_unit]
        std_days = std_value * unit_multipliers[std_unit]
        
        # Validate normal distribution rule: Î¼ - 2Ïƒ â‰¥ 0
        if mean_days - 2 * std_days < 0:
            raise ValueError(f"Invalid normal distribution: mean - 2*std_dev = {mean_days:.3f} - 2*{std_days:.3f} = {mean_days - 2*std_days:.3f} < 0. Use smaller standard deviation.")
        
        return mean_days, std_days
    
    # Fixed duration format: "1.5d"
    fixed_match = re.match(r'^(\d+\.?\d*)\s*([dhms]?)$', duration_str)
    if fixed_match:
        base_value = float(fixed_match.group(1))
        unit = fixed_match.group(2) or 'd'
        
        # Convert to days
        unit_multipliers = {'d': 1.0, 'h': 1/24, 'm': 1/(24*60), 's': 1/(24*60*60)}
        if unit not in unit_multipliers:
            raise ValueError(f"Invalid time unit: {unit}")
        
        mean_days = base_value * unit_multipliers[unit]
        return mean_days, 0.0  # No variance for fixed duration
    
    raise ValueError(f"Invalid duration format: {duration_str}. Use formats like '1.5d', '2hÂ±30m', or '1dÂ±0.5d'")


def sample_duration(duration_str: str) -> float:
    """
    Sample an actual duration from a duration specification using normal distribution.
    
    Args:
        duration_str: Duration string (e.g., "1.5dÂ±0.5d" or "1.5d")
        
    Returns:
        float: Sampled duration in days (always positive)
    """
    mean_days, std_days = parse_duration(duration_str)
    
    if std_days == 0:
        # Fixed duration - no sampling needed
        return mean_days
    
    # Sample from normal distribution with re-sampling to prevent negative values
    max_attempts = 10
    for attempt in range(max_attempts):
        sampled_duration = random.normalvariate(mean_days, std_days)
        if sampled_duration > 0:
            return sampled_duration
    
    # Fallback: if all samples were negative, return mean (shouldn't happen with proper validation)
    log.warning(f"All normal distribution samples were negative for {duration_str}, returning mean {mean_days:.3f}d")
    return mean_days




# Common duration patterns for business processes using normal distribution
DURATION_PATTERNS = {
    "fast_service": "0.5dÂ±0.1d",               # Fast service: 0.5 days Â± 2.4 hours
    "standard_service": "1dÂ±0.3d",             # Standard service: 1 day Â± 7.2 hours  
    "slow_service": "2dÂ±0.5d",                 # Slow service: 2 days Â± 12 hours
    "manufacturing": "1.5dÂ±0.4d",              # Manufacturing: 1.5 days Â± 9.6 hours
    "shipping": "3dÂ±0.8d",                     # Shipping: 3 days Â± 19.2 hours
    "approval": "0.5dÂ±0.15d",                  # Approval: 0.5 days Â± 3.6 hours
    "quick_task": "2hÂ±30m",                    # Quick task: 2 hours Â± 30 minutes
    "daily_task": "1dÂ±4h",                     # Daily task: 1 day Â± 4 hours
}


